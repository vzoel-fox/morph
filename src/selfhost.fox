; ==============================================================================
; MorphFox Self-Host v0.8 - MorphRoutine Runtime
; ==============================================================================
; Cooperative multitasking dengan context switching
; Parity: bootstrap/asm/scheduler.s, context.s
; ==============================================================================

; ------------------------------------------------------------------------------
; MORPHROUTINE STRUCTURE (64 bytes)
; ------------------------------------------------------------------------------
; Layout:
;   [0x00] RSP          - Saved stack pointer
;   [0x08] RIP          - Saved instruction pointer
;   [0x10] Status       - Routine state
;   [0x18] Fragment     - Current executing fragment
;   [0x20] ID           - Unique routine identifier
;   [0x28] Next         - Next routine in queue
;   [0x30] StackBase    - Stack bottom (high addr)
;   [0x38] StackLimit   - Stack top limit (low addr)

const R_RSP = 0
const R_RIP = 8
const R_STATUS = 16
const R_FRAGMENT = 24
const R_ID = 32
const R_NEXT = 40
const R_STACK_BASE = 48
const R_STACK_LIMIT = 56
const ROUTINE_SIZE = 64

; ------------------------------------------------------------------------------
; ROUTINE STATUS
; ------------------------------------------------------------------------------
const STATUS_READY = 0
const STATUS_RUNNING = 1
const STATUS_BLOCKED = 2
const STATUS_TERMINATED = 3

; ------------------------------------------------------------------------------
; SCHEDULER STRUCTURE (32 bytes)
; ------------------------------------------------------------------------------
; Layout:
;   [0x00] Head         - First routine in queue
;   [0x08] Tail         - Last routine in queue
;   [0x10] Current      - Currently running routine
;   [0x18] Count        - Total routines

const S_HEAD = 0
const S_TAIL = 8
const S_CURRENT = 16
const S_COUNT = 24
const SCHED_SIZE = 32

; ------------------------------------------------------------------------------
; CONTEXT SWITCH FRAME (48 bytes)
; ------------------------------------------------------------------------------
; Callee-saved registers pushed on stack:
;   [RSP+0]  R15
;   [RSP+8]  R14
;   [RSP+16] R13
;   [RSP+24] R12
;   [RSP+32] RBP
;   [RSP+40] RBX
;   [RSP+48] RIP (return address)

const CTX_R15 = 0
const CTX_R14 = 8
const CTX_R13 = 16
const CTX_R12 = 24
const CTX_RBP = 32
const CTX_RBX = 40
const CTX_RIP = 48
const CTX_FRAME_SIZE = 48

; ------------------------------------------------------------------------------
; STACK CONFIGURATION
; ------------------------------------------------------------------------------
const DEFAULT_STACK_SIZE = 8192

; ==============================================================================
; MAIN: MorphRoutine Runtime Verification
; ==============================================================================
fungsi utama() -> i64
  ; ===========================================================================
  ; Verify structure sizes match bootstrap
  ; ===========================================================================
  
  ; MorphRoutine: 64 bytes (8 fields * 8)
  var routine_size = 64
  
  ; Scheduler: 32 bytes (4 fields * 8)
  var sched_size = 32
  
  ; Context frame: 48 bytes (6 regs * 8)
  var ctx_size = 48
  
  ; Default stack: 8192 bytes
  var stack_size = 8192
  
  ; ===========================================================================
  ; Simulate spawn operation
  ; ===========================================================================
  ; scheduler_spawn allocates:
  ;   1. Routine struct: 64 bytes
  ;   2. Stack struct: 24 bytes (from stack.s)
  ;   3. Stack buffer: 8192 bytes
  ; Total per routine: 64 + 24 + 8192 = 8280 bytes
  
  var spawn_routine = 64
  var spawn_stack_struct = 24
  var spawn_stack_buf = 8192
  var t1 = spawn_routine + spawn_stack_struct
  var spawn_total = t1 + spawn_stack_buf
  
  ; ===========================================================================
  ; Simulate yield operation
  ; ===========================================================================
  ; scheduler_yield:
  ;   1. Save 6 registers (48 bytes on stack)
  ;   2. Store RSP to current routine
  ;   3. Load RSP from next routine
  ;   4. Restore 6 registers
  ;   5. Return to new routine's RIP
  
  var yield_regs = 6
  var yield_bytes = yield_regs * 8
  
  ; ===========================================================================
  ; Round-robin scheduling simulation
  ; ===========================================================================
  ; With 3 routines: Main, Worker1, Worker2
  ; Queue: [Main] -> [W1] -> [W2] -> [Main] ...
  
  var num_routines = 3
  var total_routine_mem = num_routines * spawn_total
  
  ; ===========================================================================
  ; Verification sum
  ; ===========================================================================
  ; routine=64, sched=32, ctx=48, stack=8192
  ; spawn_total=8280, yield=48, routines=3, total_mem=24840
  ; Sum = 64 + 32 + 48 + 8192 + 8280 + 48 + 3 + 24840 = 41507
  
  var s1 = routine_size + sched_size
  var s2 = s1 + ctx_size
  var s3 = s2 + stack_size
  var s4 = s3 + spawn_total
  var s5 = s4 + yield_bytes
  var s6 = s5 + num_routines
  s6 + total_routine_mem
tutup_fungsi
