; ==============================================================================
; TYPE CHECKER - MorphFox Self-Hosting Compiler
; ==============================================================================
; Type checking: AST -> Typed AST with error reporting
; Integrated with AI-Readable Hint System for enhanced diagnostics

; ambil "parser.fox"
ambil "../corelib/core/ai_hint_system.fox"
; ambil "../corelib/lib/hashmap.fox"
; ambil "../corelib/lib/vector.fox"

; Type constants
const TYPE_VOID = 0
const TYPE_I64 = 1
const TYPE_PTR = 2
const TYPE_STRING = 3
const TYPE_FUNCTION = 4
const TYPE_STRUCT = 5
const TYPE_ARRAY = 6
const TYPE_GENERIC = 7
const TYPE_UNION = 8
const TYPE_ERROR = -1

; Symbol table entry
const SYM_NAME = 0
const SYM_TYPE = 8
const SYM_SCOPE = 16
const SYM_SIZE = 24

; Struct type entry
const STRUCT_NAME = 0
const STRUCT_FIELDS = 8
const STRUCT_SIZE = 16
const STRUCT_ENTRY_SIZE = 24

; Array type entry  
const ARRAY_ELEMENT_TYPE = 0
const ARRAY_SIZE = 8
const ARRAY_ENTRY_SIZE = 16
const SYM_SCOPE = 16
const SYM_SIZE = 24

; Type checker context
const TC_SYMBOLS = 0
const TC_ERRORS = 8
const TC_SCOPE = 16
const TC_STRUCTS = 24
const TC_ALIASES = 32
const TC_GENERICS = 40
const TC_UNIONS = 48
const TC_HINTS = 56
const TC_CURRENT_LINE = 64
const TC_CURRENT_COL = 72
const TC_SIZE = 80

fungsi type_checker_new() -> ptr
  var tc = __mf_mem_alloc(TC_SIZE)
  __mf_poke_i64(tc + TC_SYMBOLS, hashmap_new())
  __mf_poke_i64(tc + TC_ERRORS, vector_new())
  __mf_poke_i64(tc + TC_SCOPE, 0)
  __mf_poke_i64(tc + TC_STRUCTS, hashmap_new())
  __mf_poke_i64(tc + TC_ALIASES, hashmap_new())
  __mf_poke_i64(tc + TC_GENERICS, hashmap_new())
  __mf_poke_i64(tc + TC_UNIONS, hashmap_new())
  __mf_poke_i64(tc + TC_HINTS, 1)  ; Enable AI hints
  __mf_poke_i64(tc + TC_CURRENT_LINE, 0)
  __mf_poke_i64(tc + TC_CURRENT_COL, 0)
  hint_system_init()
  kembali tc
tutup_fungsi

fungsi tc_add_symbol(tc: ptr, name: ptr, type: i64) -> i64
  var symbols = __mf_load_i64(tc + TC_SYMBOLS)
  var sym = __mf_mem_alloc(SYM_SIZE)
  __mf_poke_i64(sym + SYM_NAME, name)
  __mf_poke_i64(sym + SYM_TYPE, type)
  __mf_poke_i64(sym + SYM_SCOPE, __mf_load_i64(tc + TC_SCOPE))
  hashmap_insert(symbols, name, sym)
  kembali 1
tutup_fungsi

fungsi tc_lookup_symbol(tc: ptr, name: ptr) -> ptr
  var symbols = __mf_load_i64(tc + TC_SYMBOLS)
  kembali hashmap_get(symbols, name)
tutup_fungsi

fungsi tc_error(tc: ptr, msg: ptr) -> i64
  var errors = __mf_load_i64(tc + TC_ERRORS)
  vector_push(errors, msg)
  kembali TYPE_ERROR
tutup_fungsi

; AI-enhanced error with hint generation
fungsi tc_error_hint(tc: ptr, hint_code: i64, msg: ptr, suggestion: ptr) -> i64
  var errors = __mf_load_i64(tc + TC_ERRORS)
  vector_push(errors, msg)
  
  ; Generate AI hint if enabled
  var hints_enabled = __mf_load_i64(tc + TC_HINTS)
  jika hints_enabled != 0
    var line = __mf_load_i64(tc + TC_CURRENT_LINE)
    var col = __mf_load_i64(tc + TC_CURRENT_COL)
    create_hint(hint_code, line, col, msg, suggestion)
  tutup_jika
  
  kembali TYPE_ERROR
tutup_fungsi

; Set current source location for hints
fungsi tc_set_location(tc: ptr, line: i64, col: i64) -> void
  __mf_poke_i64(tc + TC_CURRENT_LINE, line)
  __mf_poke_i64(tc + TC_CURRENT_COL, col)
tutup_fungsi

fungsi tc_check_literal(tc: ptr, node: ptr) -> i64
  var data2 = __mf_load_i64(node + AST_DATA2)
  jika data2 == 1  ; String literal
    kembali TYPE_STRING
  tutup_jika
  kembali TYPE_I64  ; Integer literal
tutup_fungsi

; ==============================================================================
; TYPE INFERENCE ENGINE
; ==============================================================================

; Infer type from expression (for var without explicit type)
fungsi tc_infer_type(tc: ptr, node: ptr) -> i64
  jika node == 0
    kembali TYPE_VOID
  tutup_jika
  
  var node_type = __mf_load_i64(node + AST_TYPE)
  
  ; Literal inference
  jika node_type == AST_LITERAL
    var data2 = __mf_load_i64(node + AST_DATA2)
    jika data2 == 1
      kembali TYPE_STRING
    tutup_jika
    kembali TYPE_I64
  tutup_jika
  
  ; Identifier - lookup in symbol table
  jika node_type == AST_IDENT
    var name = __mf_load_i64(node + AST_DATA1)
    var sym = tc_lookup_symbol(tc, name)
    jika sym != 0
      kembali __mf_load_i64(sym + SYM_TYPE)
    tutup_jika
    kembali TYPE_ERROR
  tutup_jika
  
  ; Binary ops - infer from operands
  jika node_type == AST_BINARY
    kembali tc_infer_binary(tc, node)
  tutup_jika
  
  ; Function call - lookup return type
  jika node_type == AST_CALL
    kembali tc_infer_call(tc, node)
  tutup_jika
  
  ; Unary ops
  jika node_type == AST_UNARY
    kembali tc_infer_unary(tc, node)
  tutup_jika
  
  kembali TYPE_I64  ; Default fallback
tutup_fungsi

; Infer binary expression type
fungsi tc_infer_binary(tc: ptr, node: ptr) -> i64
  var children = __mf_load_i64(node + AST_CHILDREN)
  jika children == 0
    kembali TYPE_ERROR
  tutup_jika
  
  var left = vector_get(children, 0)
  var right = vector_get(children, 1)
  var op = __mf_load_i64(node + AST_DATA1)
  
  var left_type = tc_infer_type(tc, left)
  var right_type = tc_infer_type(tc, right)
  
  ; Comparison ops always return i64 (bool)
  jika op == OP_EQ
    kembali TYPE_I64
  tutup_jika
  jika op == OP_NEQ
    kembali TYPE_I64
  tutup_jika
  jika op == OP_LT
    kembali TYPE_I64
  tutup_jika
  jika op == OP_GT
    kembali TYPE_I64
  tutup_jika
  jika op == OP_LE
    kembali TYPE_I64
  tutup_jika
  jika op == OP_GE
    kembali TYPE_I64
  tutup_jika
  
  ; String concat
  jika left_type == TYPE_STRING
    jika right_type == TYPE_STRING
      jika op == OP_ADD
        kembali TYPE_STRING
      tutup_jika
    tutup_jika
  tutup_jika
  
  ; Pointer arithmetic
  jika left_type == TYPE_PTR
    jika op == OP_ADD
      kembali TYPE_PTR
    tutup_jika
    jika op == OP_SUB
      kembali TYPE_PTR
    tutup_jika
  tutup_jika
  
  ; Numeric ops
  jika left_type == TYPE_I64
    jika right_type == TYPE_I64
      kembali TYPE_I64
    tutup_jika
  tutup_jika
  
  ; Type mismatch - try to find common type
  kembali tc_common_type(left_type, right_type)
tutup_fungsi

; Infer unary expression type
fungsi tc_infer_unary(tc: ptr, node: ptr) -> i64
  var children = __mf_load_i64(node + AST_CHILDREN)
  jika children == 0
    kembali TYPE_ERROR
  tutup_jika
  
  var operand = vector_get(children, 0)
  var op = __mf_load_i64(node + AST_DATA1)
  
  var operand_type = tc_infer_type(tc, operand)
  
  ; Negation
  jika op == OP_NEG
    kembali TYPE_I64
  tutup_jika
  
  ; Logical not
  jika op == OP_NOT
    kembali TYPE_I64
  tutup_jika
  
  ; Address-of
  jika op == OP_ADDR
    kembali TYPE_PTR
  tutup_jika
  
  ; Dereference
  jika op == OP_DEREF
    kembali TYPE_I64  ; Assume i64 for now
  tutup_jika
  
  kembali operand_type
tutup_fungsi

; Infer function call return type
fungsi tc_infer_call(tc: ptr, node: ptr) -> i64
  var func_name = __mf_load_i64(node + AST_DATA1)
  
  ; Check built-in functions
  jika string_equals_simple(func_name, "sistem")
    kembali TYPE_I64
  tutup_jika
  jika string_equals_simple(func_name, "__mf_mem_alloc")
    kembali TYPE_PTR
  tutup_jika
  jika string_equals_simple(func_name, "__mf_load_i64")
    kembali TYPE_I64
  tutup_jika
  jika string_equals_simple(func_name, "__mf_poke_i64")
    kembali TYPE_VOID
  tutup_jika
  jika string_equals_simple(func_name, "vector_new")
    kembali TYPE_PTR
  tutup_jika
  jika string_equals_simple(func_name, "hashmap_new")
    kembali TYPE_PTR
  tutup_jika
  jika string_equals_simple(func_name, "string_length")
    kembali TYPE_I64
  tutup_jika
  
  ; Lookup user-defined function
  var sym = tc_lookup_symbol(tc, func_name)
  jika sym != 0
    ; TODO: Store return type in function symbol
    kembali TYPE_I64  ; Default for now
  tutup_jika
  
  kembali TYPE_I64
tutup_fungsi

; Find common type for two types
fungsi tc_common_type(t1: i64, t2: i64) -> i64
  jika t1 == t2
    kembali t1
  tutup_jika
  
  ; ptr + i64 = ptr
  jika t1 == TYPE_PTR
    jika t2 == TYPE_I64
      kembali TYPE_PTR
    tutup_jika
  tutup_jika
  jika t1 == TYPE_I64
    jika t2 == TYPE_PTR
      kembali TYPE_PTR
    tutup_jika
  tutup_jika
  
  ; Default to i64
  kembali TYPE_I64
tutup_fungsi

; Operator constants for inference
const OP_ADD = 1
const OP_SUB = 2
const OP_MUL = 3
const OP_DIV = 4
const OP_MOD = 5
const OP_EQ = 10
const OP_NEQ = 11
const OP_LT = 12
const OP_GT = 13
const OP_LE = 14
const OP_GE = 15
const OP_NEG = 20
const OP_NOT = 21
const OP_ADDR = 22
const OP_DEREF = 23

fungsi tc_check_identifier(tc: ptr, node: ptr) -> i64
  var name = __mf_load_i64(node + AST_DATA1)
  var sym = tc_lookup_symbol(tc, name)
  jika sym == 0
    kembali tc_error_hint(tc, HINT_SEMANTIC_UNDEFINED_VARIABLE, 
      "Undefined variable", "Declare variable before use with 'var name = value'")
  tutup_jika
  kembali __mf_load_i64(sym + SYM_TYPE)
tutup_fungsi

fungsi tc_check_binary(tc: ptr, node: ptr) -> i64
  var children = __mf_load_i64(node + AST_CHILDREN)
  jika children == 0
    kembali tc_error(tc, "Binary op missing operands")
  tutup_jika
  
  var left = vector_get(children, 0)
  var right = vector_get(children, 1)
  
  var left_type = tc_check_node(tc, left)
  var right_type = tc_check_node(tc, right)
  
  jika left_type == TYPE_ERROR
    kembali TYPE_ERROR
  tutup_jika
  jika right_type == TYPE_ERROR
    kembali TYPE_ERROR
  tutup_jika
  
  ; Arithmetic ops require i64
  jika left_type != TYPE_I64
    kembali tc_error_hint(tc, HINT_SEMANTIC_TYPE_MISMATCH,
      "Left operand must be i64", "Cast to i64 or use compatible type")
  tutup_jika
  jika right_type != TYPE_I64
    kembali tc_error_hint(tc, HINT_SEMANTIC_TYPE_MISMATCH,
      "Right operand must be i64", "Cast to i64 or use compatible type")
  tutup_jika
  
  kembali TYPE_I64
tutup_fungsi

fungsi tc_check_assign(tc: ptr, node: ptr) -> i64
  var children = __mf_load_i64(node + AST_CHILDREN)
  var target = vector_get(children, 0)
  var value = vector_get(children, 1)
  
  var target_type = tc_check_node(tc, target)
  var value_type = tc_check_node(tc, value)
  
  jika target_type != value_type
    kembali tc_error_hint(tc, HINT_SEMANTIC_TYPE_MISMATCH,
      "Type mismatch in assignment", "Ensure value type matches variable type")
  tutup_jika
  
  kembali target_type
tutup_fungsi

fungsi tc_check_var_decl(tc: ptr, node: ptr) -> i64
  var name = __mf_load_i64(node + AST_DATA1)
  var type = __mf_load_i64(node + AST_DATA2)
  
  ; Check initializer if present
  var children = __mf_load_i64(node + AST_CHILDREN)
  jika children != 0
    var init = vector_get(children, 0)
    var init_type = tc_infer_type(tc, init)
    
    ; Type inference: if no explicit type, use inferred
    var is_inferred = 0
    jika type == 0
      is_inferred = 1
    tutup_jika
    jika type == TYPE_VOID
      is_inferred = 1
    tutup_jika

    jika is_inferred == 1
      type = init_type
    lain
      ; Explicit type - check match
      jika init_type != type
        jika init_type != TYPE_ERROR
          kembali tc_error_hint(tc, HINT_SEMANTIC_TYPE_MISMATCH,
            "Initializer type mismatch", "Ensure initializer matches declared type")
        tutup_jika
      tutup_jika
    tutup_jika
  tutup_jika
  
  ; Add to symbol table with inferred/declared type
  tc_add_symbol(tc, name, type)
  
  kembali TYPE_VOID
tutup_fungsi

fungsi tc_check_function(tc: ptr, node: ptr) -> i64
  var name = __mf_load_i64(node + AST_DATA1)
  var return_type = __mf_load_i64(node + AST_DATA2)
  
  ; Add function to symbol table
  tc_add_symbol(tc, name, TYPE_FUNCTION)
  
  ; Enter new scope
  var old_scope = __mf_load_i64(tc + TC_SCOPE)
  __mf_poke_i64(tc + TC_SCOPE, old_scope + 1)
  
  ; Check function body
  var children = __mf_load_i64(node + AST_CHILDREN)
  jika children != 0
    var body = vector_get(children, 0)
    tc_check_node(tc, body)
  tutup_jika
  
  ; Restore scope
  __mf_poke_i64(tc + TC_SCOPE, old_scope)
  
  kembali TYPE_VOID
tutup_fungsi

fungsi tc_check_node(tc: ptr, node: ptr) -> i64
  jika node == 0
    kembali TYPE_VOID
  tutup_jika
  
  var type = __mf_load_i64(node + AST_TYPE)
  
  jika type == AST_LITERAL
    kembali tc_check_literal(tc, node)
  tutup_jika
  jika type == AST_IDENT
    kembali tc_check_identifier(tc, node)
  tutup_jika
  jika type == AST_BINARY
    kembali tc_check_binary(tc, node)
  tutup_jika
  jika type == AST_ASSIGN
    kembali tc_check_assign(tc, node)
  tutup_jika
  jika type == AST_VAR_DECL
    kembali tc_check_var_decl(tc, node)
  tutup_jika
  jika type == AST_FUNCTION
    kembali tc_check_function(tc, node)
  tutup_jika
  
  ; Default: check children
  var children = __mf_load_i64(node + AST_CHILDREN)
  jika children != 0
    var len = vector_length(children)
    var i = 0
    selama i < len
      var child = vector_get(children, i)
      tc_check_node(tc, child)
      i = i + 1
    tutup_selama
  tutup_jika
  
  kembali TYPE_VOID
tutup_fungsi

fungsi type_check_ast(ast: ptr) -> ptr
  var tc = type_checker_new()
  
  ; Add built-in functions
  tc_add_symbol(tc, "sistem", TYPE_FUNCTION)
  tc_add_symbol(tc, "__mf_mem_alloc", TYPE_FUNCTION)
  tc_add_symbol(tc, "__mf_load_i64", TYPE_FUNCTION)
  tc_add_symbol(tc, "__mf_poke_i64", TYPE_FUNCTION)
  
  tc_check_node(tc, ast)
  kembali tc
tutup_fungsi

fungsi tc_has_errors(tc: ptr) -> i64
  var errors = __mf_load_i64(tc + TC_ERRORS)
  kembali vector_length(errors)
tutup_fungsi

fungsi tc_print_errors(tc: ptr) -> i64
  var errors = __mf_load_i64(tc + TC_ERRORS)
  var len = vector_length(errors)
  var i = 0
  selama i < len
    var msg = vector_get(errors, i)
    sistem 1, 2, "Type Error: ", 12
    sistem 1, 2, msg, string_length(msg)
    sistem 1, 2, "\n", 1
    i = i + 1
  tutup_selama
  kembali len
tutup_fungsi

; Print errors with AI hints (structured output)
fungsi tc_print_errors_ai(tc: ptr) -> i64
  sistem 1, 1, "=== TYPE CHECK RESULTS (AI-READABLE) ===\n", 41
  
  var error_count = tc_print_errors(tc)
  
  jika error_count > 0
    sistem 1, 1, "\n", 1
    analyze_hints()
  lain
    sistem 1, 1, "âœ“ No type errors found\n", 26
  tutup_jika
  
  kembali error_count
tutup_fungsi
; Register struct type
fungsi tc_register_struct(tc: ptr, name: ptr, fields: ptr) -> i64
  var structs = __mf_load_i64(tc + TC_STRUCTS)
  var struct_entry = __mf_mem_alloc(STRUCT_ENTRY_SIZE)
  __mf_poke_i64(struct_entry + STRUCT_NAME, name)
  __mf_poke_i64(struct_entry + STRUCT_FIELDS, fields)
  __mf_poke_i64(struct_entry + STRUCT_SIZE, vector_size(fields) * 8)
  
  var name_hash = string_hash_simple(name)
  hashmap_insert(structs, name_hash, struct_entry)
  kembali 1
tutup_fungsi

; Check struct field access
fungsi tc_check_struct_access(tc: ptr, struct_name: ptr, field_name: ptr) -> i64
  var structs = __mf_load_i64(tc + TC_STRUCTS)
  var name_hash = string_hash_simple(struct_name)
  var struct_entry = hashmap_get(structs, name_hash)
  
  jika struct_entry == 0
    kembali tc_error_hint(tc, HINT_SEMANTIC_UNDEFINED_VARIABLE,
      "Struct type not found", "Declare struct before use")
  tutup_jika
  
  var fields = __mf_load_i64(struct_entry + STRUCT_FIELDS)
  var field_count = vector_length(fields)
  
  ; Search for field
  var i = 0
  selama i < field_count
    var field = vector_get(fields, i)
    jika string_equals_simple(field, field_name)
      ; Found - return field type (stored at i+1)
      jika i + 1 < field_count
        kembali vector_get(fields, i + 1)
      tutup_jika
      kembali TYPE_I64  ; Default
    tutup_jika
    i = i + 2  ; Skip name+type pairs
  tutup_selama
  
  kembali tc_error_hint(tc, HINT_SEMANTIC_UNDEFINED_VARIABLE,
    "Field not found in struct", "Check field name spelling")
tutup_fungsi

; Get struct field offset for codegen
fungsi tc_get_field_offset(tc: ptr, struct_name: ptr, field_name: ptr) -> i64
  var structs = __mf_load_i64(tc + TC_STRUCTS)
  var name_hash = string_hash_simple(struct_name)
  var struct_entry = hashmap_get(structs, name_hash)
  
  jika struct_entry == 0
    kembali -1
  tutup_jika
  
  var fields = __mf_load_i64(struct_entry + STRUCT_FIELDS)
  var field_count = vector_length(fields)
  var offset = 0
  
  var i = 0
  selama i < field_count
    var field = vector_get(fields, i)
    jika string_equals_simple(field, field_name)
      kembali offset
    tutup_jika
    ; Add size of this field
    var field_type = vector_get(fields, i + 1)
    offset = offset + tc_type_size(field_type)
    i = i + 2
  tutup_selama
  
  kembali -1
tutup_fungsi

; Get size of type
fungsi tc_type_size(type_id: i64) -> i64
  jika type_id == TYPE_I64
    kembali 8
  tutup_jika
  jika type_id == TYPE_PTR
    kembali 8
  tutup_jika
  jika type_id == TYPE_STRING
    kembali 16
  tutup_jika
  kembali 8
tutup_fungsi

; Create array type
fungsi tc_create_array_type(element_type: i64, size: i64) -> ptr
  var array_entry = __mf_mem_alloc(ARRAY_ENTRY_SIZE)
  __mf_poke_i64(array_entry + ARRAY_ELEMENT_TYPE, element_type)
  __mf_poke_i64(array_entry + ARRAY_SIZE, size)
  kembali array_entry
tutup_fungsi

; Check array index access
fungsi tc_check_array_access(tc: ptr, array_type: ptr, index_node: ptr) -> i64
  jika array_type == 0
    kembali tc_error_hint(tc, HINT_SEMANTIC_TYPE_MISMATCH,
      "Not an array type", "Use array type for indexing")
  tutup_jika
  
  ; Check index is i64
  var index_type = tc_infer_type(tc, index_node)
  jika index_type != TYPE_I64
    kembali tc_error_hint(tc, HINT_SEMANTIC_TYPE_MISMATCH,
      "Array index must be i64", "Convert index to integer")
  tutup_jika
  
  ; Return element type
  kembali __mf_load_i64(array_type + ARRAY_ELEMENT_TYPE)
tutup_fungsi

; Check array bounds (compile-time if possible)
fungsi tc_check_array_bounds(tc: ptr, array_type: ptr, index_value: i64) -> i64
  var array_size = __mf_load_i64(array_type + ARRAY_SIZE)
  
  ; -1 means dynamic size, skip bounds check
  jika array_size == -1
    kembali 1
  tutup_jika
  
  jika index_value < 0
    kembali tc_error_hint(tc, HINT_MEMORY_BUFFER_OVERFLOW,
      "Array index out of bounds", "Ensure 0 <= index < array_size")
  tutup_jika
  jika index_value >= array_size
    kembali tc_error_hint(tc, HINT_MEMORY_BUFFER_OVERFLOW,
      "Array index out of bounds", "Ensure 0 <= index < array_size")
  tutup_jika
  
  kembali 1
tutup_fungsi

; Register array type in type checker
fungsi tc_register_array(tc: ptr, name: ptr, element_type: i64, size: i64) -> i64
  var array_type = tc_create_array_type(element_type, size)
  var aliases = __mf_load_i64(tc + TC_ALIASES)
  var name_hash = string_hash_simple(name)
  hashmap_insert(aliases, name_hash, array_type)
  kembali 1
tutup_fungsi
; Register type alias
fungsi tc_register_alias(tc: ptr, alias_name: ptr, target_type: i64) -> i64
  var aliases = __mf_load_i64(tc + TC_ALIASES)
  var name_hash = string_hash_simple(alias_name)
  hashmap_insert(aliases, name_hash, target_type)
  kembali 1
tutup_fungsi

; Resolve type alias
fungsi tc_resolve_type(tc: ptr, type_name: ptr) -> i64
  var aliases = __mf_load_i64(tc + TC_ALIASES)
  var name_hash = string_hash_simple(type_name)
  var resolved = hashmap_get(aliases, name_hash)
  jika resolved != 0
    kembali resolved
  tutup_jika
  
  ; Built-in type lookup
  jika string_equals_simple(type_name, "i64")
    kembali TYPE_I64
  tutup_jika
  jika string_equals_simple(type_name, "ptr")
    kembali TYPE_PTR
  tutup_jika
  jika string_equals_simple(type_name, "String")
    kembali TYPE_STRING
  tutup_jika
  
  kembali TYPE_ERROR
tutup_fungsi

; Function parameter validation
fungsi tc_check_function_call(tc: ptr, func_name: ptr, args: ptr) -> i64
  var symbols = __mf_load_i64(tc + TC_SYMBOLS)
  var name_hash = string_hash_simple(func_name)
  var func_symbol = hashmap_get(symbols, name_hash)
  
  jika func_symbol == 0
    tc_error_hint(tc, HINT_SEMANTIC_UNDEFINED_VARIABLE,
      "Function not found", "Declare function before calling or check spelling")
    kembali TYPE_ERROR
  tutup_jika
  
  var func_type = __mf_load_i64(func_symbol + SYM_TYPE)
  jika func_type != TYPE_FUNCTION
    tc_error_hint(tc, HINT_SEMANTIC_TYPE_MISMATCH,
      "Not a function", "Cannot call non-function type")
    kembali TYPE_ERROR
  tutup_jika
  
  ; Simple validation - return i64 for now
  kembali TYPE_I64
tutup_fungsi

; Add error with context
fungsi tc_add_error(tc: ptr, message: ptr) -> i64
  var errors = __mf_load_i64(tc + TC_ERRORS)
  vector_push(errors, message)
  kembali 1
tutup_fungsi
; Register generic type: fungsi map<T>(arr: []T) -> []T
fungsi tc_register_generic(tc: ptr, name: ptr, type_params: ptr) -> i64
  var generics = __mf_load_i64(tc + TC_GENERICS)
  var name_hash = string_hash_simple(name)
  hashmap_insert(generics, name_hash, type_params)
  kembali 1
tutup_fungsi

; Register union type: type Result<T> = Ok(T) | Error(String)
fungsi tc_register_union(tc: ptr, name: ptr, variants: ptr) -> i64
  var unions = __mf_load_i64(tc + TC_UNIONS)
  var name_hash = string_hash_simple(name)
  hashmap_insert(unions, name_hash, variants)
  kembali 1
tutup_fungsi

; Instantiate generic type
fungsi tc_instantiate_generic(tc: ptr, generic_name: ptr, concrete_types: ptr) -> i64
  var generics = __mf_load_i64(tc + TC_GENERICS)
  var name_hash = string_hash_simple(generic_name)
  var type_params = hashmap_get(generics, name_hash)
  
  jika type_params == 0
    kembali TYPE_ERROR
  tutup_jika
  
  ; Simple instantiation - return concrete type
  var first_concrete = vector_get(concrete_types, 0)
  kembali first_concrete
tutup_fungsi

; Check union variant
fungsi tc_check_union_variant(tc: ptr, union_name: ptr, variant_name: ptr) -> i64
  var unions = __mf_load_i64(tc + TC_UNIONS)
  var name_hash = string_hash_simple(union_name)
  var variants = hashmap_get(unions, name_hash)
  
  jika variants == 0
    kembali TYPE_ERROR
  tutup_jika
  
  ; Simple variant check - return union type
  kembali TYPE_UNION
tutup_fungsi
